# pyright: strict
import typing
import dataclasses as dc

from . import subject as slvs_subject
from . import format as slvs_format
from . import field as slvs_field
from . import record as slvs_record


_ADD_INSTRUCTION = {
    b"AddGroup": slvs_subject.Tag.GROUP,
    b"AddParam": slvs_subject.Tag.PARAM,
    b"AddRequest": slvs_subject.Tag.REQUEST,
    b"AddEntity": slvs_subject.Tag.ENTITY,
    b"AddConstraint": slvs_subject.Tag.CONSTRAINT,
    # https://github.com/solvespace/solvespace/blob/e7c0c1665f1684bb3195107147aaf254c852fa44/src/file.cpp#L531-L539
    b"AddSurface": None,
    b"AddCurve": None,
}

_VERSION_STRING = b"\xb1\xb2\xb3SolveSpaceREVa"


# https://github.com/solvespace/solvespace/blob/e7c0c1665f1684bb3195107147aaf254c852fa44/src/file.cpp#L531-L539
# solvespace codebase comments say that this is regenerated by solvespace upon loading the file anyway,
# so all of this saved data (surfaces, curves, etc.) is purelyâ€¦ for decoration? (maybe it's useful for
# external tools generating file previews, STL exports, etc.?
_IGNORE_INSTRUCTION = {
    b"Surface",
    b"SCtrl",
    b"TrimBy",
    b"Curve",
    b"CCtrl",
    b"CurvePt",
}


@dc.dataclass
class Sketch:
    groups: dict[int, slvs_record.Record] = dc.field(default_factory=dict, kw_only=True)
    params: dict[int, slvs_record.Record] = dc.field(default_factory=dict, kw_only=True)
    entities: dict[int, slvs_record.Record] = dc.field(default_factory=dict, kw_only=True)
    constraints: dict[int, slvs_record.Record] = dc.field(default_factory=dict, kw_only=True)
    requests: dict[int, slvs_record.Record] = dc.field(default_factory=dict, kw_only=True)
    styles: dict[int, slvs_record.Record] = dc.field(default_factory=dict, kw_only=True)

    def by_subject_tag(self):
        return {
            slvs_subject.Tag.GROUP: self.groups,
            slvs_subject.Tag.PARAM: self.params,
            slvs_subject.Tag.ENTITY: self.entities,
            slvs_subject.Tag.CONSTRAINT: self.constraints,
            slvs_subject.Tag.REQUEST: self.requests,
            slvs_subject.Tag.STYLE: self.styles,
        }

    def serialize(self, out: typing.BinaryIO):
        by_subject_tag = self.by_subject_tag()

        out.write(_VERSION_STRING)
        out.write(b"\n\n\n")
        for add_command, subject_tag in _ADD_INSTRUCTION.items():
            if subject_tag is None:
                continue
            for record in by_subject_tag[subject_tag].values():
                record.serialize(subject_tag, out)
                out.write(add_command)
                out.write(b"\n\n")

    @classmethod
    def parse(cls, lines: typing.BinaryIO) -> typing.Self:
        version_string = lines.readline().rstrip()
        assert version_string == b"\xb1\xb2\xb3SolveSpaceREVa"

        sketch = cls()
        by_subject_tag = sketch.by_subject_tag()
        buffer: dict[slvs_subject.Tag, slvs_record.Partial] = {
            subject: slvs_record.Partial() for subject in slvs_subject.Tag
        }

        for line in lines:
            match line.rstrip().split(b"=", 1):
                case [b""]:  # empty line
                    continue

                case [singleton]:
                    if singleton in _ADD_INSTRUCTION:
                        subject = _ADD_INSTRUCTION[singleton]
                        if subject is None:  # ignored command
                            continue
                        record = buffer[subject].finalize()
                        by_subject_tag[subject][record.id] = record
                        buffer[subject] = slvs_record.Partial()
                        continue

                    if singleton.split()[0] in _IGNORE_INSTRUCTION:
                        continue
                    raise ValueError(f"unrecognized instruction", singleton)

                case [left, right]:
                    # record entry
                    field = slvs_field.LOOKUP[left]
                    value = slvs_format.BY_TAG[field.format].parse(right, lines)
                    buffer[field.subject].data[field.key] = value

                case _:
                    # should never happen, we run `split` with `maxsplit=1`, so the resulting
                    # list contains at most two elements; meanwhile, per documentation, since
                    # the separator is explicitly given, the resulting list will always contain
                    # at least one element
                    assert False

        return sketch
